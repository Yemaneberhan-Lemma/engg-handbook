---
weight: 1
---

# Principles of Software Development at Axelerant

> "Principles are ways of successfully dealing with reality to get what you want out of life." - Ray Dalio

A software engineer has to make a lot of decisions throughout their day. Defining and following certain _principles_ make it easier for you to make many of the decisions for challenges that have been solved previously. These are not set in stone but they have stood the test of time and you would rarely ignore a principle and only if there's a very good reason.

## Engineering Focus

Axelerant has traditionally been an Engineering focused company. We begin on strong fundamentals and aim to build a robust and useful solution. The solution needs to be robust so that our customers can trust it and it needs to be useful so that our customers derive value out of it. While we are focused on Engineering, we are still solving problems for people and that means we have to think of what our customers need.

## Build for people

We don't write code in a vacuum. We write code to solve problems for our customer, using systems used by their customers, all of which will be maintained by your teammates. We write code once but it is read many times and executed significantly more times.

### Solve the problem

You could write the most beautiful, most efficient, most poetic code you possibly can, but if it doesn't help your customer, it doesn't help anyone. Write great code and solve the problem.

### Write readable code

Do not try to be clever with your code. There is a saying that debugging is harder than writing code. So if you write the cleverest possible code then, by definition, you are not clever enough to debug it.

Write your code so that it can be read and understood by other people.

## Focus on Fundamentals

We balance the value of getting started quickly with a robust understanding of the fundamentals. [Read More]({{< relref "fundamentals" >}})

### Understand the technology deeply

We understand why things work the way they do. We learn and build our knowledge every day. Our customers rely on us to solve their technological problems and we can't do that without understanding the technology. [Read More]({{< relref "fundamentals#technology" >}})

#### Understand how computers work

We write programs to tell computers how to solve a problem. How can you do that unless you know how they work?! [Read More]({{< relref "fundamentals#computers" >}})

#### Understand how Internet works

Internet is a crucial part of computing today and almost all of what Axelerant does. Therefore, understanding it is crucial as well. [Read More]({{< relref "fundamentals#internet" >}})

#### Understand how operating systems work

Don't forget the operating system when working on your code. It's meant to be invisible but not for those programming for them. [Read More]({{< relref "fundamentals#os" >}})

#### Understand programming languages

Programming languages are how you tell the computer to solve a problem. Speak it well. [Read More]({{< relref "fundamentals#languages" >}})

##### Distinguish types of programming languages

We use many programming languages and you should know which to use when. [Read More]({{< relref "fundamentals#language-types" >}})

### Understand why we use anything

Understand the fundamentals and make a sound decision on what to use and how. [Read More]({{< relref "fundamentals#anything" >}})

### Working with source code

The code you write is a valuable asset. Manage it well. [Read More]({{< relref "fundamentals#source-code" >}})

#### Reading vs Writing code

The code that you write will be read many more times and executed a lot more times. Optimize your code for reading and execution. [Read More]({{< relref "fundamentals#reading-code" >}})

## Ask for help

At Axelerant, we don't expect you to know everything. We hired you for your strengths and put you in a team where other's strengths complement yours. Use them.

## Be bold and experiment

Life's too short to wait for permission. Understand decision-making models and use them to make decisions when they are cheap and reversible (most decisions are). Worst case, you learn something new. Best case, you learn something and we all succeed.

## Test, test, and test again

Being quick with decisions doesn't mean we are quick with that deployment. We test to make sure that our work, _works_. Then we verify our tests and get another opinion to make sure we tested the right thing and tested it well.

Yes, the customer will tell you if what you did doesn't work well but you lose trust. Build trust with your actions.

## Automate your way to laziness

Life's too short to repeat things (I know I am repeating this but life's too short to find new maxims). Figure out a way to automate things you are doing repeatedly and frequently.

## Be a part of the massive open-source community

There's a very good chance you are not living in a remote jungle or a lonely mountaintop. That's because you have come to rely on the support (and comfort) provided by clusters of people in cities and towns. Why should our programming world be any different?
